#include <stdio.h>                    // подключение стандартной библиотеки ввода/вывода      
#include <stdlib.h>                   // содержит в себе функции, занимающиеся выделением памяти
#include <string.h>                   // подключение стандартной библиотеки для работы со строками
#include <unistd.h>                   // содержит символические константы и структуры, которые еще не были описаны в каких-либо других включаемых файлах
#include <sys/ipc.h>                  // подключение библиотеки для работы с ключами IPC
#include <sys/shm.h>                  // подключение библиотеки для работы с разделяемой памятью
#include <sys/wait.h>                 // подключение библиотеки для работы с процессами
#include <stdbool.h>                  // подключение библиотеки для работы с типом данных bool
#include "shm_com.h"                  // подключение заголовочного файла с определениями для разделяемой памяти



/**************************************************************************/
/*                  П Р О Т О Т И П Ы   Ф У Н К Ц И Й                     */
/**************************************************************************/

// очистка буфера ввода
void clearInputBuffer();

// печать приветственного ASCII-арта
void print_ASCII();

// печать прощального ASCII-арта
void print_END();

// выбор действия пользователем
void getchoice(char* choice,          // указатель на первый элемент массива символов выбора
               char* filepath_ish,    // указатель на первый элемент массива пути к зашифрованному файлу
               char* filepath_shifr); // указатель на первый элемент массива пути к расшифрованному файлу



/*------------------------------------------------------------------------*/
/*                Функции               */
/*--------------------------------------*/

/*----------------------------------------------------------*/
/*         Очистка буфера ввода          */
/*---------------------------------------*/

void clearInputBuffer() 
{
    int c;

    // чтение символов из входного буфера до тех пор, пока не будет достигнут символ новой строки ('\n') или конец файла (EOF) 
    while ((c = getchar()) != '\n' && c != EOF) { }

    // символ равен новой строке или концу файла, while-цикл завершается. Управление передаётся основной функции
    return;
}



/*----------------------------------------------------------*/
/*   Печать приветственного ASCII-арта    */
/*----------------------------------------*/

void print_ASCII()
{
    // выводим ASCII-арт начала
    printf("\n\033[38;5;219m     ____       _   _       _         ____     U _____ u   ____            __  __   U _____ u   __  __      U  ___ u\n");
    printf("    / __\"| u   |'| |'|  U  /\"\\  u  U |  _\"\\ u  \\| ___\"|/  |  _\"\\         U|' \\/ '|u \\| ___\"|/ U|' \\/ '|u     \\/\"_ \\/\n");
    printf("   <\\___ \\/   /| |_| |\\  \\/ _ \\/    \\| |_) |/   |  _|\"   /| | | |        \\| |\\/| |/  |  _|\"   \\| |\\/| |/     | | | |\n");
    printf("    u___) |   U|  _  |u  / ___ \\     |  _ <     | |___   U| |_| |\\        | |  | |   | |___    | |  | |  .-,_| |_| |\n");
    printf("    |____/>>   |_| |_|  /_/   \\_\\    |_| \\_\\    |_____|   |____/ u        |_|  |_|   |_____|   |_|  |_|   \\_)-\\___/\n");
    printf("     )(  (__)  //   \\\\   \\\\    >>    //   \\\\_   <<   >>    |||_          <<,-,,-.    <<   >>  <<,-,,-.         \\\\\n");
    printf("    (__)      (_\") (\"_) (__)  (__)  (__)  (__) (__) (__)  (__)_)          (./  \\.)  (__) (__)  (./  \\.)       (__)\033[0m\n\n\n\n");

    return;                           // вернули обещанное функцией значение             
}



/*----------------------------------------------------------*/
/*   Печать прощального ASCII-арта   */
/*-----------------------------------*/

void print_END()
{
    // выводим ASCII-арт окончания
    printf("\n\033[38;5;219m\t\t\t  _____     _   _   U _____ u      U _____ u   _   _       ____\n");
    printf("\t\t\t |_ \" _|   |'| |'|  \\| ___\"|/      \\| ___\"|/  | \\ |\"|     |  _\"\\\n");
    printf("\t\t\t   | |    /| |_| |\\  |  _|\"         |  _|\"   <|  \\| |>   /| | | |\n");
    printf("\t\t\t  /| |\\   U|  _  |u  | |___         | |___   U| |\\  |u   U| |_| |\\\n");
    printf("\t\t\t u |_|U    |_| |_|   |_____|        |_____|   |_| \\_|     |____/ u\n");
    printf("\t\t\t _// \\\\_   //   \\\\   <<   >>        <<   >>   ||   \\\\,-.   |||_\n");
    printf("\t\t\t(__) (__) (_\") (\"_) (__) (__)      (__) (__)  (_\")  (_/   (__)_)\033[0m\n\n\n");

    return;                           // вернули обещанное функцией значение             
}



/*----------------------------------------------------------*/
/*   Выбор действия пользователем   */
/*----------------------------------*/

void getchoice(char* choice,          // указатель на первый элемент массива символов выбора
               char* filepath_ish,    // указатель на первый элемент массива пути к зашифрованному файлу
               char* filepath_shifr)  // указатель на первый элемент массива пути к расшифрованному файлу  
{
    memset(choice, 0, sizeof(*choice));     // очистка массива выбора пользователя перед вводом
    scanf(" %s", choice);                   // ввод выбора пользователя с клавиатуры
   
    // бесконечный цикл ввода выбора действия
    while(true)
    {
        if (strlen(choice) == 1)            // в ответе пользователя должна содержаться одна буква
        {
            // пользователь выбрал зашифровать файл
            if (choice[0] == 'A' || choice[0] == 'a') 
            {
               // выводим всю необходимую информацию
               printf("\033[38;5;48m\t\t\t    М Е Ж П Р О Ц Е С С Н О Е   В З А И М О Д Е Й С Т В И Е\033[0m\n\n");
               printf("\033[38;5;214mР О Д И Т Е Л Ь С К И Й   П Р О Ц Е С С:\033[0m\n\n");
               printf("Начинаем шифровать исходный файл: %s\n", filepath_ish);
               break;                       // прерываем цикл ввода выбора
            }// if(choice[0] == 'A' || choice[0] == 'a') 

            // пользователь выбрал расшифровать файл
            else if (choice[0] == 'B' || choice[0] == 'b')
            {
                // выводим всю необходимую информацию
                printf("\n\n\033[38;5;48m\t\t\t    М Е Ж П Р О Ц Е С С Н О Е   В З А И М О Д Е Й С Т В И Е\033[0m\n\n");
                printf("\033[38;5;214mР О Д И Т Е Л Ь С К И Й   П Р О Ц Е С С:\033[0m\n\n");
                printf("Начинаем расшифровывать зашифрованный файл: %s\n", filepath_shifr);
                break;                      // прерываем цикл ввода выбора
            }// else if(choice[0] == 'B' || choice[0] == 'b')

            // пользователь выбрал выйти из программы
            else if (choice[0] == 'C' || choice[0] == 'c')
            {
                // выводим всю необходимую информацию
                printf("\n\n\033[38;5;48m\t\t\t    М Е Ж П Р О Ц Е С С Н О Е   В З А И М О Д Е Й С Т В И Е\033[0m\n\n");
                print_END();                // выводим надпись окончания программы
                exit(0);                    // заканчиваем программу из функции
            }// else if(choice[0] == 'C' || choice[0] == 'c')

            // пользователь ввел неправильную букву выбора
            else
            {
                // просим осуществить повторный ввод
                printf("\033[38;5;230mПопробуйте ввести выбор заново - введённое значение не соответствует ни одному из предложенных\033[0m\n");
                printf("*****\n");
                printf("Ввод: ");
                memset(choice, 0, sizeof(*choice)); // очистка массива выбора ввода перед новым вводом
                scanf("%s", choice);                // просим повторить ввод - цикл начинается заново
            }// else
        }

        // пользователь ввел несколько символов при выборе
        else
        {   
            // просим осуществить повторный ввод
            printf("\033[38;5;230mПопробуйте ввести выбор заново - введённое значение не соответствует ни одному из предложенных\033[0m\n");
            printf("*****\n");
            printf("Ввод: ");
            memset(choice, 0, sizeof(*choice));     // очистка массива выбора ввода перед новым вводом
            scanf("%s", choice);                    // просим повторить ввод - цикл начинается заново
        }// if(strlen(choice) == 1)

    }// while()

    return;                                         // возвращаем обещанное значение
}



/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/

// работа с аргументами командной строки
int main(int argc, char *argv[]) 
{
    // проверка на количество аргументов командной строки
    if (argc < 5) 
    {
        // вывод сообщения об использовании программы с описанием ожидаемых параметров командной строки
        // используется stderr для вывода сообщения об ошибке
        fprintf(stderr, "Использование: ./<исполняемый файл> <путь_к_файлу_с_исходным кодом> <путь_к_файлу-шифратору>\n\t\t\t\t    <путь_к_зашифрованному_файлу> <путь_к_расшифрованному_файлу>\n");
        
        // выход из программы с кодом EXIT_FAILURE,
        // чтобы показать, что программа завершилась из-за ошибочного использования
        exit(EXIT_FAILURE);
    }// if(argc < 5)  

    char choice[100];                               // выбор пользователя действий в программе
    char no_has_file = true;                        // флаг того, создан ли зашифрованный файл, чтобы его расшифровать
    char encryptedFilePath[256];                    // переменная для пути к зашифрованному файлу
    char decryptedFilePath[256];                    // переменная для пути к расшифрованному файлу
    strcpy(encryptedFilePath, argv[3]);             // копируем введённую пользователем директорию до зашифрованного файла в переменную пути
    strcat(encryptedFilePath, "/shifr.txt");        // добавляем к пути название файла в директории - полный путь до файла

    strcpy(decryptedFilePath, argv[4]);             // копируем введённую пользователем директорию до расшифрованного файла в переменную пути
    strcat(decryptedFilePath, "/translate.txt");    // добавляем к пути название файла в директории - полный путь до файла 

    // бесконечный цикл работы
    while(1)
    {

        system("clear");                            // очищаем экран перед выводом
        print_ASCII();                              // печать приветственной надписи на экран
        
        // печать на экран введённых пользователем путей
        printf("\033[38;5;122m\t\t\t\t С П Р А В О Ч Н А Я   И Н Ф О Р М А Ц И Я\033[0m\n\n");
        printf("Путь до файла для шифрования:\t\t\t  %s\n", argv[1]);
        printf("Путь до файла со случайной последовательностью:   %s\n", argv[2]);
        printf("Путь до зашифрованного файла:\t\t\t  %s\n", encryptedFilePath);
        printf("Путь до расшифрованного файла, если он создаётся: %s\n\n", decryptedFilePath);

        // печать на экран возможных действий в программе
        printf("\n\033[38;5;51m\t\t\t    В С Ё   З А В И С И Т   О Т   П О Л Ь З О В А Т Е Л Я\033[0m\n\n");
        printf("Выберите действие:\n");
        printf("\033[48;5;134ma)\033[0m Зашифровать файл\n");
        printf("\033[48;5;49mb)\033[0m Расшифровать файл\n");
        printf("\033[48;5;148mc)\033[0m Выйти из программы\n\n");
        printf("Ввод: ");

        // обрабатываем пользовательский ввод
        getchoice(choice, argv[1], encryptedFilePath);

        // если когда-то ранее уже генерировался зашифрованный файл
        // то устанавливаем флаг того, что мы его можем расшифровать
        if (access(encryptedFilePath, F_OK) != -1)
        {
            no_has_file = false;                    // снимаем флаг того, что нет зашифрованного файла
        }// if(access(encryptedFilePath, F_OK) != -1)

        // ранее не было создано зашифрованного файла и пользователь выбрал расшифровку
        if (no_has_file && !(choice[0] == 'a' || choice[0] == 'A'))
        {
            // ничего расшифровать не можем - файла не было создано ранее
            // уведомляем пользователя
            printf("\033[48;5;196mОШИБКА!!! Сначала создайте файл с шифром\033[0m");
            clearInputBuffer();                     // чистим буфер ввода
            getchar();                              // ожидаем ввода символа для продолжения
            continue;                               // запускаем цикл выбора действия заново
        }// if(no_has_file && !(choice[0] == 'a' || choice[0] == 'A'))
        
        // возвращаемое значение ключа будет одинаковым для одного и того же файла при 
        // одинаковом значении идентификатора проекта, но будет различаться, если файлы или
        // идентификаторы проекта отличаются
        key_t key = ftok("/tmp", 'A');              // генерируем ключ к общей разделяемой памяти

        // преобразуем key в строку - для передачи в дочернюю программу
        char key_str[20];                           // массив с символьным значением ключа
        sprintf(key_str, "%d", (int)key);           // преобразуем ключ в строку
        int segm;                                   // номер сегмента общей разделяемой памяти - значение будет прибавляться к ключу

        // создание сегмента разделяемой памяти для дочернего процесса 1, который обрабатывает исходный/зашифрованный файл
        segm = 1;

        // создание разделяемого сегмента памяти
        // - key + segm: ключ для сегмента (может быть комбинацией ключа и номера сегмента)
        // - sizeof(struct shared_data_original): размер создаваемого сегмента памяти
        // - IPC_CREAT | 0666: флаги создания и права доступа к сегменту
        int shmid1 = shmget(key+segm, sizeof(struct shared_data_original), IPC_CREAT | 0666);
    
        // не удалось создать сегмент_1 разделяемой памяти
        if (shmid1 == -1)
        {
            perror("shmget провалилась\n");         // если вызов функции shmget завершился ошибкой, выводим сообщение об ошибке
            exit(EXIT_FAILURE);                     // выход из программы с кодом EXIT_FAILURE, так как создание сегмента_1 не удалось
        }// if(shmid1 == -1)

        // присоединение сегмента_1 разделяемой памяти к адресному пространству процесса с помощью функции shmat.
        // - shmid1: идентификатор сегмента разделяемой памяти
        // - NULL: указание на систему выбрать адрес для присоединения
        // - 0: флаги присоединения (в данном случае обычное присоединение)
        struct shared_data_original *shared_memory1 = (struct shared_data_original *)shmat(shmid1, NULL, 0);
        
        // выводим указатель на сегмент разделяемой памяти
        printf("\033[38;5;135mУказатель на сегмент 1\033[0m разделяемой памяти в родительской программе: \033[38;5;228m%p\033[0m\n", (void *)shared_memory1);
    
        // присоединить сегмент_1 разделяемой памяти не удалось
        if (shared_memory1 == (struct shared_data_original *)(-1)) 
        {
            perror("shmat провалилась");            // если вызов функции shmat завершился ошибкой, выводим сообщение об ошибке
            exit(EXIT_FAILURE);                     // выход из программы с кодом EXIT_FAILURE, так как присоединение сегмента_1 не удалось
        }// if(shared_memory1 == (struct shared_data_original *)(-1)) 


        // создание сегмента разделяемой памяти для дочернего процесса 2, который обрабатывает файл со случайной последовательностью символов
        segm = 2;

        // создание разделяемого сегмента памяти
        // - key + segm: ключ для сегмента (может быть комбинацией ключа и номера сегмента)
        // - sizeof(struct shared_data_original): размер создаваемого сегмента памяти
        // - IPC_CREAT | 0666: флаги создания и права доступа к сегменту
        int shmid2 = shmget(key+segm, sizeof(struct shared_data_code), IPC_CREAT | 0666);

        // не удалось создать сегмент_2 разделяемой памяти
        if (shmid2 == -1)
        {
            perror("shmget провалилась\n");         // если вызов функции shmget завершился ошибкой, выводим сообщение об ошибке
            exit(EXIT_FAILURE);                     // выход из программы с кодом EXIT_FAILURE, так как создание сегмента_2 не удалось
        }// if(shmid2 == -1) 

        // присоединение сегмента_2 разделяемой памяти к адресному пространству процесса с помощью функции shmat.
        // - shmid2: идентификатор сегмента разделяемой памяти
        // - NULL: указание на систему выбрать адрес для присоединения
        // - 0: флаги присоединения (в данном случае обычное присоединение)
        struct shared_data_code *shared_memory2 = (struct shared_data_code *)shmat(shmid2, NULL, 0);

        // выводим указатель на сегмент разделяемой памяти
        printf("\033[38;5;135mУказатель на сегмент 2\033[0m разделяемой памяти в родительской программе: \033[38;5;228m%p\033[0m\n\n", (void *)shared_memory2);
    
        // присоединить сегмент_2 разделяемой памяти не удалось
        if (shared_memory2 == (struct shared_data_code *)(-1)) 
        {
            perror("shmat провалилась");            // если вызов функции shmat завершился ошибкой, выводим сообщение об ошибке
            exit(EXIT_FAILURE);                     // выход из программы с кодом EXIT_FAILURE, так как присоединение сегмента_2 не удалось
        }// if(shared_memory2 == (struct shared_data_code *)(-1)) 
    
        //---------------------------------------------------------------------------------------------------------------------------

        // начинаем работать с дочерними процессами - делаем fork()
        printf("\n\033[38;5;214mД О Ч Е Р Н И Е   П Р О Ц Е С С Ы:\033[0m\n\n");

        // СОЗДАЁМ ДОЧЕРНИЙ ПРОЦЕСС_1
        pid_t pid1 = fork();                        // в pid1 ID дочернего процесса. Создаём копию родительского процесса
       
        if (pid1 < 0)                               // ошибка форкинга
        {
            // вывод сообщения об использовании fork()
            // используется stderr для вывода сообщения об ошибке
            fprintf(stderr, "Ошибка при вызове fork()\n");
            exit(EXIT_FAILURE);                     // выход из программы с кодом EXIT_FAILURE, так как создание дочернего процесса не удалось
        }// if(pid1 < 0)

        // дочерний процесс
        else if (pid1 == 0) 
        {
            // дочерний процесс 1
            segm = 1;
            char segm_str[20];                      // символьный массив для хранения номера сегмента
            sprintf(segm_str, "%d", (int)segm);     // преобразование int в строку для передачи в execl

            // пользователь зашифровывает исходный файл - считываем исходный файл
            if (choice[0] == 'a' || choice[0] == 'A')
            {
                // выполняем замену текущего процесса исполняемым файлом PROVIDER с передачей аргументов:
                // - argv[1]: путь до исходного файла, который необходимо зашифровать
                // - key_str: строка, содержащая ключ сегмента разделяемой памяти
                // - segm_str: строка, содержащая номер сегмента разделяемой памяти
                (void)execl("PROVIDER", "PROVIDER", argv[1], key_str, segm_str,  NULL);
            }

            // пользователь декодирует зашифрованный файл - считываем зашифрованный файл
            else
            {
                // выполняем замену текущего процесса исполняемым файлом PROVIDER с передачей аргументов:
                // - encryptedFilePath: путь до файла, который необходимо расшифровать
                // - key_str: строка, содержащая ключ сегмента разделяемой памяти
                // - segm_str: строка, содержащая номер сегмента
                (void)execl("PROVIDER", "PROVIDER", encryptedFilePath, key_str, segm_str,  NULL);
            }// if(choice[0] == 'a' || choice[0] == 'A')

        }// else if(pid1 == 0) 

        // родительский процесс
        else 
        {
            // создаём еще один дочерний процесс для обработки случайной последовательности
            // СОЗДАЁМ ДОЧЕРНИЙ ПРОЦЕСС_2
            pid_t pid2 = fork();

            if (pid2 < 0)                           // в pid2 ID дочернего процесса. Создаём копию родительского процесса
            {
                // вывод сообщения об использовании fork()
                // используется stderr для вывода сообщения об ошибке
                fprintf(stderr, "Ошибка при вызове fork()\n");
                exit(EXIT_FAILURE);                 // выход из программы с кодом EXIT_FAILURE, так как создание дочернего процесса не удалось
            }// if(pid2 < 0)

            else if (pid2 == 0) 
            {
                // дочерний процесс 2
                segm = 2;              
                char segm_str[20];                  // символьный массив для хранения номера сегмента
                sprintf(segm_str, "%d", (int)segm); // преобразование int в строку для передачи в execl

                // выполняем замену текущего процесса исполняемым файлом PROVIDER с передачей аргументов:
                // - argv[2]: путь до файла со случайной последовательностью шифрования
                // - key_str: строка, содержащая ключ сегмента разделяемой памяти
                // - segm_str: строка, содержащая номер сегмента разделяемой памяти
                (void)execl("PROVIDER", "PROVIDER", argv[2], key_str, segm_str,  NULL);
            }// else if(pid2 == 0)  

            else 
            {
                // Родительский процесс
                waitpid(pid1, NULL, 0);             // ожидание завершения родительским процессом работы дочернего процесса 1
                waitpid(pid2, NULL, 0);             // ожидание завершения родительским процессом работы дочернего процесса 2
                
                // подсвечиваем, что вернулись обратно в родительский процесс
                printf("\n\033[38;5;214mР О Д И Т Е Л Ь С К И Й   П Р О Ц Е С С:\033[0m\n\n");

                // выводим считанные данные из сегмента_1 разделяемой памяти - хранятся в соответствующей структуре
                printf("\033[38;5;204mСчитанные данные родительской программой из сегмента 1:\033[0m\n");
                // выводим считанные данные на экран: или исходный файл, или зашифрованный файл
                printf("%s\n", shared_memory1->data);
                // при расшифровке файла утрачивается символ переноса в конце считанной строки файла -> при выводе добавляем его в консоль, чтобы текст "не слипался"
                if (choice[0] == 'B' || choice[0] == 'b')
                {
                    printf("\n");
                }// if (choice[0] == 'B' || choice[0] == 'b')

                // выводим считанные данные из сегмента_2 разделяемой памяти - хранятся в соответствующей структуре
                printf("\033[38;5;204mСчитанные данные родительской программой из сегмента 2:\033[0m\n");
                // выводим считанные данные на экран - случайная последовательность символов шифрации
                printf("%s\n", shared_memory2->data);

                // определение длины наименьшей считанной информации для побитовой операции в цикле
                // длина считанной последовательности из сегмента_1 разделяемой памяти: исходного или зашифрованного файла
                int len1 = strlen(shared_memory1->data);
                // длина считанной последовательности из сегмента_2 разделяемой памяти: шифрующей случайной последовательности символов
                int len2 = strlen(shared_memory2->data);

                // выбираем наименьшую из двух полученных длин
                int min_len = (len1 < len2) ? len1 : len2;
                // выводим её на экран
                printf("Длина минимальной считанной строки из разделённой памяти: %i\n\n", min_len);
                
                // создание результирующего массива и побитовая операция XOR - в зависимости от содержимого сегмента_1
                // получим зашифрованный или расшифрованный файл в зависимости от содержимого сегмента_1 разделяемой памяти
                // массив выделяем на 1 элемент больше для добавления символа оконсания строки
                char result[min_len + 1];

                // проходим по считанному содержимому наименьшей длины
                for (size_t i = 0; i < min_len; i++) 
                {
                    // побитово выполняем операцию XOR между данными из shared_memory1 и shared_memory2
                    // результат операции записываем в массив result
                    result[i] = shared_memory1->data[i] ^ shared_memory2->data[i];
                }// for

                result[min_len] = '\0';             // добавляем завершающий нуль-символ в результирующую последовательность
                // выводим полученную последовательность на экран
                printf("\033[38;5;122mРезультат побитовой операции XOR:\033[0m\n%s\n\n", result);

                // пользователь выбрал опцию зашифровать файл
                if (choice[0] == 'a' || choice[0] == 'A')
                {
                    // открываем файл для записи по пути для зашифрованного файла (очищаем содержимое)
                    FILE *file = fopen(encryptedFilePath, "w"); 
                    // проверяем успешность открытия файла
                    if (file == NULL) 
                    {
                        // возникла ошибка, выводим сообщение об ошибке и завершаем программу
                        perror("Ошибка открытия файла");
                        exit(EXIT_FAILURE);
                    }// if(file == NULL) 

                    // в случае успешного открытия файла, сообщаем об успешном создании файла с шифром
                    printf("\nФайл с шифром успешно создан;\n");
                    fprintf(file, result);          // записываем данные из массива result в открытый файл
                    fclose(file);                   // закрываем файл
                    // сообщаем об успешном заполнении файла с шифром
                    printf("Файл с шифром успешно заполнен;");
                    no_has_file = false;            // устанавливаем флаг no_has_file в значение false, чтобы указать, что файл с шифром был создан
                } 

                // пользователь выбрал расшифровать файл
                else
                {
                    // открываем файл для записи по пути для расшифрованного файла (очищаем содержимое)
                    FILE *file = fopen(decryptedFilePath, "w");
                    // проверяем успешность открытия файла
                    if (file == NULL) 
                    {
                        // возникла ошибка, выводим сообщение об ошибке и завершаем программу
                        perror("Ошибка открытия файла");
                        exit(EXIT_FAILURE);
                    }// if(file == NULL) 

                    // в случае успешного открытия файла, сообщаем об успешном создании файла с расшифрованной последовательностью
                    printf("Файл с декодированием шифра успешно создан;\n");
                    fprintf(file, result);          // записываем данные из массива result в открытый файл
                    fclose(file);                   // закрываем файл

                    // сообщаем об успешном заполнении файла с расшифрованной последовательностью
                    printf("Файл с декодированием шифра успешно заполнен;");
                }// if(choice[0] == 'a' || choice[0] == 'A') // Если выбрано зашифровать файл
                
                // отсоединяем области разделяемой памяти shared_memory1 и shared_memory2 после их использования
                // аргумент: адрес области разделяемой памяти для отсоединения
                shmdt(shared_memory1);
                shmdt(shared_memory2);

                // освобождаем ресурсы областей разделяемой памяти, чтобы они могли быть использованы другими процессами
                // аргументы: идентификатор сегмента памяти, действие (IPC_RMID для удаления), дополнительные параметры (NULL)
                shmctl(shmid1, IPC_RMID, NULL);
                shmctl(shmid2, IPC_RMID, NULL);
            }// else

        }// else 
        clearInputBuffer();                         // чистим буфер ввода
        getchar();                                  // ожидаем ввод символа для продолжения
    }// while
    
    return 0;                                       // возвращаем обещанное значение
}